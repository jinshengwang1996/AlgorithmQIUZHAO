# 学习笔记

## 刷题记录

严格按照超哥给出的五毒神掌刷题：以下是自己每天刷题的数目。

**第一周**

周一：

两数之和：4

移动零：4

周二：

加一：4

爬楼梯：4

盛最多水的容器：4

三个数之和：4

周三：

反转链表：4

两两交换链表中的结点：4

移除重复元素：4

周四：

旋转数组：4

合并两个有序数组：4

周五：

合并两个有序链表：4

有效的字母异位词：4



**第二周**

周一：

二叉树的中序遍历：4

二叉树的前序遍历：4

周二：

N叉树的前序遍历：4

N叉树的后序遍历：4

周三：

最小的k个数：4

前k个高频元素：4

周四：

组合：4

N叉树的层序遍历：4

周五：

丑数：4



**第三周**

周一：

多数元素：3

周二：

二叉树的层序遍历：3

周三：

分发饼干：3

搜索二维矩阵：3

周四：

Pow(x, n) ：3

N 皇后：3

周五：

买卖股票的最佳时机：3

寻找旋转排序数组的中的最小值：3



## 学习总结

### 分治和回溯

**分治：**

分治：顾名思义，分而治之。将问题分解为最小重复子问题，然后进行递归，与递归的原理是类似的。

**分治的代码模板：**

![](https://gitee.com/j_s_wang/blog_image_staging/raw/master/img/20200801201614.png)



**回溯：**

回溯：采用试错的思想，尝试发现现有的分步答案不能有效的得到正确的解答时，将取消上一步甚至是上几步的计算，再通过它的可能的分步解答再次尝试寻找问题的答案。

回溯法通常采用最简单的递归方法来实现，在反复重复上述步骤后可能出现两种情况：

- 找到一个可能存在的正确答案；
- 在尝试了所有可能的分步方法后，宣告问题没有解答

在最坏的情况下，回溯法会导致一次复杂度为指数时间的计算



### 深度优先搜索和广度优先搜索

![](https://gitee.com/j_s_wang/blog_image_staging/raw/master/img/20200801203638.png)

将三个代码模板背下来，然后往里面填入相应的代码，形成肌肉记忆，一碰到这类题目，直接就 **pia pia pia** 写出来。



![](https://gitee.com/j_s_wang/blog_image_staging/raw/master/img/20200801203530.png)



![](https://gitee.com/j_s_wang/blog_image_staging/raw/master/img/20200801203618.png)



![](https://gitee.com/j_s_wang/blog_image_staging/raw/master/img/20200801203653.png)



### 贪心算法

贪心算法：一种在每一步选择中都采取在当下状态下最好或最优的选择，从而希望导致结果是全局最优的算法。

贪心算法与动态规划的不同之处在于它对每个子问题的解决方案都做出选择，不能回退。但是动态规划会保存以前的运算结果，并根据以前的结果对当前进行选择，有回退功能。

利用贪心法可以解决一些优化问题：图中的最小生成树等，一般在实际工程中，不用贪心算法。一旦一个问题可以通过贪心法来解决，那么贪心法一般是这个问题的最优解，贪心法可以用作辅助算法，或解决一些要求结果不特别精确的问题。



**贪心法的反例：**

![](https://gitee.com/j_s_wang/blog_image_staging/raw/master/img/20200801203056.png)



![](https://gitee.com/j_s_wang/blog_image_staging/raw/master/img/20200801203107.png)



**应用贪心法的场景：**

问题能够分解成子问题来解决，子问题的最优解可以递推到最终问题的最优解。



### 二分查找

前提条件：

1. 目标函数单调
2. 存在上下界（bounded）
3. 能够通过索引来访问（index accessible）

```cpp
bool binary_search(vector<int> arr, int target) {
    int left = 0, right = arr.size() - 1;
    while (left <= right) {
        mid = left + (right - left) / 2;
        if (arr[mid] == target) return true;
		else if (arr[mid] < target) left = mid + 1;
        else right = mid - 1;
    }  
    return false;
}
```



## 超哥课堂作业

使用二分查找，寻找一个半有序数组 [4, 5, 6, 7, 0, 1, 2] 中间无序的地方

思路：

代码：

```cpp

```



# 本周学习心得

不得不说，这周的知识点相对来说比之前的都要大，主要还是递归的问题，因为之前递归没有特别熟悉，没有特别熟练掌握递归的那种思想，这周的大部分时间用在了刷题上，往往一个题目就是两三个小时，看了一种解法觉得挺好的，自己就会忍不住想要去尝试一下，在量上没有达到自己预计的目标和要求，不过在质上，还是有一点点提升的。(就是看着别人的代码觉得写的真不错，这个好这个好，心里还会自我讽刺一下，nb plus，我怎么就不会，真丫的强，就是有那种想背下来的冲动)



在分治和回溯那一块，我没怎么理解，于是就回去看超哥关于递归的解法，有那么一点点感觉了。背了超哥的关于DFS和BFS的代码模板，一开始 是真的不会用，还一头雾水，做了几个题目又回头理解一遍，发现还真是那么回事。只要熟悉了模板之后，我发现一个题目在理解了题目之后，用模板就是5分钟的事情。



最后以在群里看到的关于递归的理解作为结尾：循环和递归本质都是一样的，循环的话，传递的是索引，本质也是不断下探到下一层。



PS：再难也要坚持下去，即使少做，也不可以不做。
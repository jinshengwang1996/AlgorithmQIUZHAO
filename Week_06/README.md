# 学习笔记

## 刷题记录

严格按照超哥给出的五毒神掌刷题：以下是自己每天刷题的数目。

**第一周**

周一：

两数之和：4

移动零：4

周二：

加一：4

爬楼梯：4

盛最多水的容器：4

三个数之和：4

周三：

反转链表：4

两两交换链表中的结点：4

移除重复元素：4

周四：

旋转数组：4

合并两个有序数组：4

周五：

合并两个有序链表：4

有效的字母异位词：4



**第二周**

周一：

二叉树的中序遍历：4

二叉树的前序遍历：4

周二：

N叉树的前序遍历：4

N叉树的后序遍历：4

周三：

最小的k个数：4

前k个高频元素：4

周四：

组合：4

N叉树的层序遍历：4

周五：

丑数：4



**第三周**

周一：

多数元素：4

周二：

二叉树的层序遍历：4

周三：

分发饼干：4

搜索二维矩阵：4

周四：

Pow(x, n) ：4

N 皇后：4

周五：

买卖股票的最佳时机：4

寻找旋转排序数组的中的最小值：4



**第四周：**为了深入理解递归的原理，将之前的一些比较经典的题目又做了一遍，或者重新做了一下，不然来不及。课后作业只完成了6道题

递归题解合集：

周一：

翻转二叉树：4

验证二叉搜索树：4

最小路径和：4

周二：

二叉树的最大深度：4

二叉树的最小深度：4

解码方法：4

周三：

任务调度器：4

最大正方形：4

周四：

N叉树的最大深度：4

回文子串：4

周五：

最长有效括号：4





**第五周：**

周一：

爬楼梯：5

比特位计数：4

周二：

朋友圈：4

周三：

括号生成：4

周四：

岛屿数量：4

解数独：4

周五：

单词接龙：4



**第六周：**

周一：

仅仅反转字母：3

周二：

最长上升子序列：3

周三：

合并区间：3

周四：

最长回文子串：3

反转字符串中的单词III：3

周五：

通配符匹配：3

找到字符串中所有的字母异位词：3



## 学习总结

### 布隆过滤器 Bloom Filter，LRU Catch

**布隆过滤器：**

一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。



优点是空间效率和查询时间都远远超过一般的算法， 缺点是有一定的误识别率和删除困难。

布隆过滤器示意图：

![](https://gitee.com/j_s_wang/blog_image_staging/raw/master/img/20200821204106.png)



**Cache 缓存：**

1. 记忆；2. 钱包 - 储物柜；3. 代码模块

**LRU Catch** 

- 两个要素：大小、替换策略 （1. LFU - Least Frequently used； 2. LRU - Least Recently used）

- Hash Table + Double LinkedList

- O(1)  查询

  O(1) 修改、更新

替换算法总览：https://en.wikipedia.org/wiki/Cache_replacement_policies

![](https://gitee.com/j_s_wang/blog_image_staging/raw/master/img/20200821204531.png)



### 排序

**排序算法：**

1. 比较类排序：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破 O(nlogn) ，因此也称为非线性时间比较类排序。
2. 非比较类排序：不通过比较来决定元素的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。

![](https://gitee.com/j_s_wang/blog_image_staging/raw/master/img/20200821205329.png)



![](https://gitee.com/j_s_wang/blog_image_staging/raw/master/img/20200821210108.png)



**初级排序 - O(n^2)：**

1. 选择排序 (Seletion Sort) ： 每次找最小值，然后放到待排序数组的起始位置；
2. 插入排序 (insert Sort) ：从前到后逐步构建有序序列；对于未排序的数据，在已排序序列中从后向前扫描，找到相应位置并插入；
3. 冒泡排序 (Bubble Sort)：嵌套循环，每次查看相邻元素如果逆序，则交换

**高级排序 - O(nlogn)：**

1. 快速排序 (Quick Sort) ：数组取标杆 pivot，将小元素放在pivot的左边，大元素放在 pivot的右边，然后依次对左边和右边的子数组继续快排；以达到整个序列有序。

2. 归并排序 (Merge Sort)  —— 分治

   1 将长度为n的输入序列分成两个长度为n/2的子序列

   2 对这两个子序列分别采用归并排序

   3 将两个排序好的子序列合并成一个最终的排序序列

3. 堆排序 (Heap Sort) ：—— 堆插入(O(log N), 取最大/小值 O(1)

   1 数组元素依次建立小顶堆

   2 依次取堆顶元素，并删除

4. 归并和快排具有相似性，但步骤相反

   1 归并 ： 先排序左右子数组，然后合并两个有序的子数组

   2 快排：先调配出左右子数组，然后对于左右子数组进行排序

**特殊排序 - O(n)：**

- 计数排序（Counting Sort）
  计数排序要求输入的数据必须是有确定范围的整数。将输入的数据值转化为键存储在额外开辟的数组空间中；然后依次把计数大于 1 的填充回原数组
- 桶排序（Bucket Sort）
  桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。
- 基数排序（Radix Sort）
  基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。



### 高级动态规划

复杂度来源

1. 状态拥有更多维度（二维、三维、或者更多、甚至需要压缩）

2. 状态方程更加复杂

   本质其实还是内功、逻辑思维、数学思想



### 字符串

熟悉字符串常见的操作，以及语言相关的API，主要有回文串，异位词问题，最长子串，子序列等基本问题；以及一些高级算法，如，Rabin - Karp 算法，KMP 算法等。



# 本周学习心得

做到现在为止，也刷了将近有80个题目了吧，相比于之前，自己进步确实是很大的，但是自己在递归和之后的课程确实学习的不够好，尽管自己尽力避免人肉递归，但是自己在潜意识里还是会有这种不好的习惯，在极客大学毕业以后，我也一定克制自己，争取向超哥看齐，继续刷题，帮助自己巩固数据结构与算法的知识。



时间过得很快，马上就要毕业了，这也意味着马上就要离开极客大学，从极客大学毕业了。说实话还有些许的舍不得，虽然刷题的好多个日夜自己都想过放弃，都想过结束，都想过安逸，但是最后还是咬着牙坚持下来了，虽然自己理解的慢，做题的进度不佳。超哥也说过贵在回顾，一定要多过遍数，这样这个题目你才有印象。



PS：再难也要坚持下去，即使少做，也不可以不做。